epi <- SEIR.simulator(M = test_network, N=N, beta=1,ki = 3, thetai = 7, ke = 3, latencydist = "gamma")
View(epi)
plotepitree(epi)
plotepitree(epi)
fix(SEIR.simulator)
#Load Packages
require(epinet)
require(network)
require(lhs)
#Function to generate Dyadic Cov Matrix of connected mini-Hagellochs
createNewHagelloch <- function(N, id_list, Nhags,town_btw=1000, town_in=100){
#generate Class vectors
Class1_vec = sample(0:1,N,replace = T)
Class2_vec =abs(1-Class1_vec)
#generate sex vectors
Male_vec = sample(0:1,N,replace=T)
Female_vec = abs(1-Male_vec)
#generate house positions
#1) get pop size of each mini hagelloch
popSize_list <-sort(sample(1:N,(Nhags-1)))
popSize_list <-c(0,popSize_list,N)
popSizes <-diff(popSize_list)
#2) get town x,y coordinates
town_xposvec <- lapply(1:Nhags, function(x) rep( town_btw*runif(1),popSizes[x]))
town_xposvec <- unlist(town_xposvec)
town_yposvec <- lapply(1:Nhags, function(x) rep( town_btw*runif(1),popSizes[x]))
town_yposvec <- unlist(town_yposvec)
house_xposvec <- town_in*runif(N)+town_xposvec
house_yposvec <- town_in*runif(N)+town_yposvec
#set up data frame with spatial positions of N individuals (random x and y) and class, gender, age
mycov <- data.frame(id =id_list, house_xpos = house_xposvec, house_ypos = house_yposvec,HouseHold = rep(0,N),
Class1 = Class1_vec, Class12 =rep(0,N),
Male = Male_vec, FemaleM = rep(0,N),
age = sample(1:13,N, replace = T),
town_xpos=town_xposvec, town_ypos = town_yposvec)
#generate dyadic cov matrix
dyadCov <- BuildDyadicCovMatrix(mycov, unaryCol = c(4,9), unaryFunc = c("absdiff","absdiff"),
binaryCol = list(c(2,3), c(5,6),c(7,8),c(10,11)), binaryFunc = c("euclidean","euclidean","euclidean","euclidean"))
#create columns with correct matching indicators (reverse from distance)
dyadCov <- cbind(dyadCov, Class2 = abs(rep(1,dim(dyadCov)[1])-dyadCov[,'Class1.Class12.L2Dist']), Female = abs(rep(1,dim(dyadCov)[1])-dyadCov[,'Male.FemaleM.L2Dist']))
dyadCov[,'Class1.Class12.L2Dist'] <- dyadCov[,'Class2']
dyadCov[,'Male.FemaleM.L2Dist'] <- dyadCov[,'Female']
#replace values with 0s for match
dyadCov[Class2_vec[dyadCov[,'node.1']] == 0,'Class2'] <-0
dyadCov[Class1_vec[dyadCov[,'node.1']] == 0,'Class1.Class12.L2Dist'] <-0
dyadCov[Female_vec[dyadCov[,'node.1']] == 0,'Female'] <-0
dyadCov[Male_vec[dyadCov[,'node.1']] == 0,'Male.FemaleM.L2Dist'] <-0
#Reorder columns to match format of original Hagelloch data matrix
dyadCov <- dyadCov[,c(1:4,7,10, 6, 8, 11,5,9)]
colnames(dyadCov) <- c(colnames(HagellochDyadCov), "Town Distance")
colnames(dyadCov)[11] <- 'Town Distance'
dyadCov[dyadCov[,'House Distance']<3,'House Distance'] <-0
dyadCov[dyadCov[,'House Distance'] <3, 'Household'] <-1
dyadCov[dyadCov[,'Town Distance']>0,c('Classroom 2', 'Classroom 1', 'Male Match',
'Female Match', 'Household','Age Diff')]<-0
newHagelloch <-dyadCov
return(newHagelloch)
}
#Create Mega-Hagelloch
N<-1000  #Total population
id_list <- 1:N  #ids
Nhags <- 10
newHag <- createNewHagelloch(N, id_list, Nhags,town_btw=1000, town_in=100 )
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.0004*N
eta_vec <- c(0,eta_vec)
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
plot.network(as.network(test_network))
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.00004*N
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
plot.network(as.network(test_network))
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.00004
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
plot.network(as.network(test_network))
epi <- SEIR.simulator(M = test_network, N=N, beta=2,ki = 5, thetai = 5, ke = 2, latencydist = "gamma")
View(epi)
plotepitrees(epi)
plotepitree(epi)
#Load Packages
require(epinet)
require(network)
require(lhs)
#Function to generate Dyadic Cov Matrix of connected mini-Hagellochs
createNewHagelloch <- function(N, id_list, Nhags,town_btw=1000, town_in=100){
#generate Class vectors
Class1_vec = sample(0:1,N,replace = T)
Class2_vec =abs(1-Class1_vec)
#generate sex vectors
Male_vec = sample(0:1,N,replace=T)
Female_vec = abs(1-Male_vec)
#generate house positions
#1) get pop size of each mini hagelloch
popSize_list <-sort(sample(1:N,(Nhags-1)))
popSize_list <-c(0,popSize_list,N)
popSizes <-diff(popSize_list)
#2) get town x,y coordinates
town_xposvec <- lapply(1:Nhags, function(x) rep( town_btw*runif(1),popSizes[x]))
town_xposvec <- unlist(town_xposvec)
town_yposvec <- lapply(1:Nhags, function(x) rep( town_btw*runif(1),popSizes[x]))
town_yposvec <- unlist(town_yposvec)
house_xposvec <- town_in*runif(N)+town_xposvec
house_yposvec <- town_in*runif(N)+town_yposvec
#set up data frame with spatial positions of N individuals (random x and y) and class, gender, age
mycov <- data.frame(id =id_list, house_xpos = house_xposvec, house_ypos = house_yposvec,HouseHold = rep(0,N),
Class1 = Class1_vec, Class12 =rep(0,N),
Male = Male_vec, FemaleM = rep(0,N),
age = sample(1:13,N, replace = T),
town_xpos=town_xposvec, town_ypos = town_yposvec)
#generate dyadic cov matrix
dyadCov <- BuildDyadicCovMatrix(mycov, unaryCol = c(4,9), unaryFunc = c("absdiff","absdiff"),
binaryCol = list(c(2,3), c(5,6),c(7,8),c(10,11)), binaryFunc = c("euclidean","euclidean","euclidean","euclidean"))
#create columns with correct matching indicators (reverse from distance)
dyadCov <- cbind(dyadCov, Class2 = abs(rep(1,dim(dyadCov)[1])-dyadCov[,'Class1.Class12.L2Dist']), Female = abs(rep(1,dim(dyadCov)[1])-dyadCov[,'Male.FemaleM.L2Dist']))
dyadCov[,'Class1.Class12.L2Dist'] <- dyadCov[,'Class2']
dyadCov[,'Male.FemaleM.L2Dist'] <- dyadCov[,'Female']
#replace values with 0s for match
dyadCov[Class2_vec[dyadCov[,'node.1']] == 0,'Class2'] <-0
dyadCov[Class1_vec[dyadCov[,'node.1']] == 0,'Class1.Class12.L2Dist'] <-0
dyadCov[Female_vec[dyadCov[,'node.1']] == 0,'Female'] <-0
dyadCov[Male_vec[dyadCov[,'node.1']] == 0,'Male.FemaleM.L2Dist'] <-0
#Reorder columns to match format of original Hagelloch data matrix
dyadCov <- dyadCov[,c(1:4,7,10, 6, 8, 11,5,9)]
colnames(dyadCov) <- c(colnames(HagellochDyadCov), "Town Distance")
colnames(dyadCov)[11] <- 'Town Distance'
dyadCov[dyadCov[,'House Distance']<3,'House Distance'] <-0
dyadCov[dyadCov[,'House Distance'] <3, 'Household'] <-1
dyadCov[dyadCov[,'Town Distance']>0,c('Classroom 2', 'Classroom 1', 'Male Match',
'Female Match', 'Household','Age Diff')]<-0
newHagelloch <-dyadCov
return(newHagelloch)
}
#Create Hagellopolis
N<-1000  #Total population
id_list <- 1:N  #ids
Nhags <- 10
newHag <- createNewHagelloch(N, id_list, Nhags,town_btw=1000, town_in=100 )
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.00004
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
#Plot Network
plot.network(as.network(test_network))
#Simulate epidemic on network
epi <- SEIR.simulator(M = test_network, N=N, beta=2,ki = 5, thetai = 5, ke = 2, latencydist = "gamma")
#Plot spread of epidemic
plotepitrees(epi)
#Load Packages
require(epinet)
require(network)
require(lhs)
#Function to generate Dyadic Cov Matrix of connected mini-Hagellochs
createNewHagelloch <- function(N, id_list, Nhags,town_btw=1000, town_in=100){
#generate Class vectors
Class1_vec = sample(0:1,N,replace = T)
Class2_vec =abs(1-Class1_vec)
#generate sex vectors
Male_vec = sample(0:1,N,replace=T)
Female_vec = abs(1-Male_vec)
#generate house positions
#1) get pop size of each mini hagelloch
popSize_list <-sort(sample(1:N,(Nhags-1)))
popSize_list <-c(0,popSize_list,N)
popSizes <-diff(popSize_list)
#2) get town x,y coordinates
town_xposvec <- lapply(1:Nhags, function(x) rep( town_btw*runif(1),popSizes[x]))
town_xposvec <- unlist(town_xposvec)
town_yposvec <- lapply(1:Nhags, function(x) rep( town_btw*runif(1),popSizes[x]))
town_yposvec <- unlist(town_yposvec)
house_xposvec <- town_in*runif(N)+town_xposvec
house_yposvec <- town_in*runif(N)+town_yposvec
#set up data frame with spatial positions of N individuals (random x and y) and class, gender, age
mycov <- data.frame(id =id_list, house_xpos = house_xposvec, house_ypos = house_yposvec,HouseHold = rep(0,N),
Class1 = Class1_vec, Class12 =rep(0,N),
Male = Male_vec, FemaleM = rep(0,N),
age = sample(1:13,N, replace = T),
town_xpos=town_xposvec, town_ypos = town_yposvec)
#generate dyadic cov matrix
dyadCov <- BuildDyadicCovMatrix(mycov, unaryCol = c(4,9), unaryFunc = c("absdiff","absdiff"),
binaryCol = list(c(2,3), c(5,6),c(7,8),c(10,11)), binaryFunc = c("euclidean","euclidean","euclidean","euclidean"))
#create columns with correct matching indicators (reverse from distance)
dyadCov <- cbind(dyadCov, Class2 = abs(rep(1,dim(dyadCov)[1])-dyadCov[,'Class1.Class12.L2Dist']), Female = abs(rep(1,dim(dyadCov)[1])-dyadCov[,'Male.FemaleM.L2Dist']))
dyadCov[,'Class1.Class12.L2Dist'] <- dyadCov[,'Class2']
dyadCov[,'Male.FemaleM.L2Dist'] <- dyadCov[,'Female']
#replace values with 0s for match
dyadCov[Class2_vec[dyadCov[,'node.1']] == 0,'Class2'] <-0
dyadCov[Class1_vec[dyadCov[,'node.1']] == 0,'Class1.Class12.L2Dist'] <-0
dyadCov[Female_vec[dyadCov[,'node.1']] == 0,'Female'] <-0
dyadCov[Male_vec[dyadCov[,'node.1']] == 0,'Male.FemaleM.L2Dist'] <-0
#Reorder columns to match format of original Hagelloch data matrix
dyadCov <- dyadCov[,c(1:4,7,10, 6, 8, 11,5,9)]
colnames(dyadCov) <- c(colnames(HagellochDyadCov), "Town Distance")
colnames(dyadCov)[11] <- 'Town Distance'
dyadCov[dyadCov[,'House Distance']<3,'House Distance'] <-0
dyadCov[dyadCov[,'House Distance'] <3, 'Household'] <-1
dyadCov[dyadCov[,'Town Distance']>0,c('Classroom 2', 'Classroom 1', 'Male Match',
'Female Match', 'Household','Age Diff')]<-0
newHagelloch <-dyadCov
return(newHagelloch)
}
#Create Hagellopolis
N<-1000  #Total population
id_list <- 1:N  #ids
Nhags <- 10
newHag <- createNewHagelloch(N, id_list, Nhags,town_btw=1000, town_in=100 )
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.00002
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
#Plot Network
plot.network(as.network(test_network))
#Simulate epidemic on network
epi <- SEIR.simulator(M = test_network, N=N, beta=2,ki = 5, thetai = 5, ke = 2, latencydist = "gamma")
#Plot spread of epidemic
plotepitree(epi)
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.00001
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
#Plot Network
plot.network(as.network(test_network))
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.00005
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
#Plot Network
plot.network(as.network(test_network))
#Simulate epidemic on network
epi <- SEIR.simulator(M = test_network, N=N, beta=2,ki = 5, thetai = 5, ke = 2, latencydist = "gamma")
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.000005
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
#Plot Network
plot.network(as.network(test_network))
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.0000005
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
#Plot Network
plot.network(as.network(test_network))
eta_vec
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.000000
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
#Plot Network
plot.network(as.network(test_network))
#Simulate epidemic on network
epi <- SEIR.simulator(M = test_network, N=N, beta=2,ki = 5, thetai = 5, ke = 2, latencydist = "gamma")
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.00004
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
#Plot Network
plot.network(as.network(test_network))
#Load Packages
require(epinet)
require(network)
require(lhs)
#Function to generate Dyadic Cov Matrix of connected mini-Hagellochs
createNewHagelloch <- function(N, id_list, Nhags,town_btw=1000, town_in=100){
#generate Class vectors
Class1_vec = sample(0:1,N,replace = T)
Class2_vec =abs(1-Class1_vec)
#generate sex vectors
Male_vec = sample(0:1,N,replace=T)
Female_vec = abs(1-Male_vec)
#generate house positions
#1) get pop size of each mini hagelloch
popSize_list <-sort(sample(1:N,(Nhags-1)))
popSize_list <-c(0,popSize_list,N)
popSizes <-diff(popSize_list)
#2) get town x,y coordinates
town_xposvec <- lapply(1:Nhags, function(x) rep( town_btw*runif(1),popSizes[x]))
town_xposvec <- unlist(town_xposvec)
town_yposvec <- lapply(1:Nhags, function(x) rep( town_btw*runif(1),popSizes[x]))
town_yposvec <- unlist(town_yposvec)
house_xposvec <- town_in*runif(N)+town_xposvec
house_yposvec <- town_in*runif(N)+town_yposvec
#set up data frame with spatial positions of N individuals (random x and y) and class, gender, age
mycov <- data.frame(id =id_list, house_xpos = house_xposvec, house_ypos = house_yposvec,HouseHold = rep(0,N),
Class1 = Class1_vec, Class12 =rep(0,N),
Male = Male_vec, FemaleM = rep(0,N),
age = sample(1:13,N, replace = T),
town_xpos=town_xposvec, town_ypos = town_yposvec)
#generate dyadic cov matrix
dyadCov <- BuildDyadicCovMatrix(mycov, unaryCol = c(4,9), unaryFunc = c("absdiff","absdiff"),
binaryCol = list(c(2,3), c(5,6),c(7,8),c(10,11)), binaryFunc = c("euclidean","euclidean","euclidean","euclidean"))
#create columns with correct matching indicators (reverse from distance)
dyadCov <- cbind(dyadCov, Class2 = abs(rep(1,dim(dyadCov)[1])-dyadCov[,'Class1.Class12.L2Dist']), Female = abs(rep(1,dim(dyadCov)[1])-dyadCov[,'Male.FemaleM.L2Dist']))
dyadCov[,'Class1.Class12.L2Dist'] <- dyadCov[,'Class2']
dyadCov[,'Male.FemaleM.L2Dist'] <- dyadCov[,'Female']
#replace values with 0s for match
dyadCov[Class2_vec[dyadCov[,'node.1']] == 0,'Class2'] <-0
dyadCov[Class1_vec[dyadCov[,'node.1']] == 0,'Class1.Class12.L2Dist'] <-0
dyadCov[Female_vec[dyadCov[,'node.1']] == 0,'Female'] <-0
dyadCov[Male_vec[dyadCov[,'node.1']] == 0,'Male.FemaleM.L2Dist'] <-0
#Reorder columns to match format of original Hagelloch data matrix
dyadCov <- dyadCov[,c(1:4,7,10, 6, 8, 11,5,9)]
colnames(dyadCov) <- c(colnames(HagellochDyadCov), "Town Distance")
colnames(dyadCov)[11] <- 'Town Distance'
dyadCov[dyadCov[,'House Distance']<3,'House Distance'] <-0
dyadCov[dyadCov[,'House Distance'] <3, 'Household'] <-1
dyadCov[dyadCov[,'Town Distance']>0,c('Classroom 2', 'Classroom 1', 'Male Match',
'Female Match', 'Household','Age Diff')]<-0
newHagelloch <-dyadCov
return(newHagelloch)
}
#Create Hagellopolis
N<-1000  #Total population
id_list <- 1:N  #ids
Nhags <- 10
newHag <- createNewHagelloch(N, id_list, Nhags,town_btw=1000, town_in=100 )
#Set up etas for network
eta_vec <- -.25*randomLHS(1,8)
eta_vec[4]<- -.0004*N/Nhags
eta_vec[8] <- -.00004
eta_vec <- c(0,eta_vec)
#Build static ERGM from Hagellopolis
test_network <- BuildDyadicLinearERGM(N=N, dyadiccovmat = newHag, eta = eta_vec)
#Plot Network
plot.network(as.network(test_network))
#Simulate epidemic on network
epi <- SEIR.simulator(M = test_network, N=N, beta=2,ki = 5, thetai = 5, ke = 2, latencydist = "gamma")
#Plot spread of epidemic
plotepitree(epi)
load("~/Dropbox/Princeton/1904schoolmeasles/Hagellopolis/EpiSpace.RData")
par(mfrow=c(3,3))
x<- c(1:9)
plot1 <-function(x) plotepitreeMod(epilist[[x]],regenVec[x])
lapply(x, plot1)
plotepitreeMod <-function (epi, regenFreq, lwd = 1, leaf.labs = TRUE, leaf.cex = 0.75, zero.at.start = FALSE,
main = "Spread of Epidemic", xlab = "Time", ylab = "", e.col = "black",
i.col = "red", lty.transmission = 3, marktransitions = TRUE,
label.trans = "|", cex.trans = 0.5, ...)
{
ninf <- nrow(epi)
if (ninf < 2)
stop("Plot error: need at least two infecteds to plot the epidemic.")
susc <- NULL
for (i in 1:ninf) if (sum(is.na(epi[i, 3:5])) == 3)
susc <- c(susc, i)
if (length(susc) > 0)
epi <- epi[-susc, ]
ninf <- nrow(epi)
if (ninf < 2)
stop("Plot error: need at least two infecteds to plot the epidemic.")
if (sum(is.na(epi[, 3:5])) > 0)
stop("Plot error: need full data to plot the epidemic -- run again with all times known.")
if (sum(is.na(epi[, 1])) > 0)
stop("Plot error: missing entries in first (Node ID) column.")
if (sum(is.na(epi[, 2])) > 1)
stop("Plot error: too many NA values in second (Parent) column -- should only have one initial infected node.")
if (zero.at.start)
epi[, 3:5] = epi[, 3:5] - min(epi[, 3:5])
epi <- epi[order(epi[, 3]), ]
nchild = array(0, max(epi[, 1]))
for (i in ninf:2) nchild[epi[i, 2]] = nchild[epi[i, 2]] +
nchild[epi[i, 1]] + 1
ypos = array(0, max(epi[, 1]))
ypos[epi[1, 1]] = 1
for (i in 2:ninf) {
ypos[epi[i, 1]] = ypos[epi[i, 2]] + nchild[epi[i, 2]] -
nchild[epi[i, 1]]
nchild[epi[i, 2]] = nchild[epi[i, 2]] - nchild[epi[i,
1]] - 1
}
plot(x = c(min(epi[, 3]), max(epi[, 5]) + 2), y = c(0.9,
ninf), pch = " ", xlab = xlab, ylab = ylab, main = c(main,"Regeneration Frequency =", 100*regenFreq,"%"),
yaxt = "n", bty = "n", ...)
for (i in 1:ninf) {
lines(x = c(epi[i, 3], epi[i, 4]), y = c(ypos[epi[i,
1]], ypos[epi[i, 1]]), lwd = lwd, col = e.col)
lines(x = c(epi[i, 4], epi[i, 5]), y = c(ypos[epi[i,
1]], ypos[epi[i, 1]]), lwd = lwd, col = i.col)
lines(x = c(epi[i, 3], epi[i, 3]), y = c(ypos[epi[i,
2]], ypos[epi[i, 1]]), lwd = lwd, lty = lty.transmission)
}
if (leaf.labs)
text(epi[, 5], ypos[epi[, 1]], labels = epi[, 1], pos = 4,
offset = 0.25, cex = leaf.cex)
if (marktransitions)
for (i in 1:ninf) text(epi[i, 4], ypos[epi[i, 1]], labels = label.trans,
cex = cex.trans)
}
par(mfrow=c(3,3))
x<- c(1:9)
plot1 <-function(x) plotepitreeMod(epilist[[x]],regenVec[x])
lapply(x, plot1)
load("~/Dropbox/Princeton/1904schoolmeasles/Hagellopolis/EpiSpace.RData")
par(mfrow=c(3,3))
x<- c(1:9)
plot1 <-function(x) plotepitreeMod(epilist[[x]],regenVec[x])
lapply(x, plot1)
par(mfrow=c(3,3))
x<- c(10:18)
plot1 <-function(x) plotepitreeMod(epilist[[x]],regenVec[x])
lapply(x, plot1)
par(mfrow=c(3,2))
x<- c(19:25)
plot1 <-function(x) plotepitreeMod(epilist[[x]],regenVec[x])
lapply(x, plot1)
source('~/Dropbox/Princeton/1904schoolmeasles/Hagellopolis/EpiListScript.R')
source('~/Dropbox/Princeton/1904schoolmeasles/Hagellopolis/EpiListScript.R')
source('~/Dropbox/Princeton/1904schoolmeasles/Hagellopolis/EpiListScript.R')
load("~/Dropbox/Princeton/1904schoolmeasles/Hagellopolis/CaliSpace.RData")
require(epinet)
plotepitree(ep1)
plotepitree(epi1)
View(epi1)
View(epi1)
fix(SEIR.simulator)
View(dyadCov)
load("~/Dropbox/Princeton/1904schoolmeasles/Hagellopolis/CaliSpace3.RData")
View(epi1)
test_epi <- epi1
View(test_epi)
inf_time <-sort(test_epi$Itime)
inf_time <-sort(test_epi[,'Itime'])
View(inf_time)
inf_time <-floor(inf_time)
View(inf_time)
inf_time <-inf_time+7
View(inf_time)
table(inf_time)
tail(inf_time)
infs <- table(inf_time)
View(infs)
require(epinet)
q()
install.packages("plotrix")
setwd("~/Dropbox/Princeton/1904schoolmeasles/Hagellopolis")
source("fastHag.R")
source("simseir.R")
#Create Hagellopolis
n_pop <- 10000  #Total population
n_hags <- 10 # number of villages
hagopolis_size = 1000 # size of landscape (square sides)
hag_size = 10 # size of a single village
# get covariates for each village
ndcv = sim_node_cov(n_pop, n_hags, city_size = hagopolis_size, village_size = hag_size)
# record info about villages
village = data.frame(table(ndcv$village), unique(ndcv$village_xpos), unique(ndcv$village_ypos))
names(village) <- c("id", "pop", "xpos", "ypos")
village$index = cumsum(c(1,village$pop))[1:n_hags]
# make up eta vector
eta_vec <- -.25 * randomLHS(1, 8)
eta_vec[4]<- -.004 * n_pop / n_hags
eta_vec[8] <- -.004
eta_vec <- c(eta_vec)
# simulate edges within villages
ptm = proc.time()
within_edges = sim_within_village_edges(node_cov = ndcv, eta = eta_vec, village_vec = 1:n_hags)
proc.time() - ptm
# simulate edges between villages
ptm1 = proc.time()
btwn_edges = sim_between_village_edges(village, eta = -0.04, ndcv)
proc.time() - ptm1
# stick them together
my_ergm = rbind(within_edges, btwn_edges)
M = my_ergm
N = n_pop
beta = 0.3
ke = 2
ki = 2
thetae = 5
thetai = 5
latencydist = "fixed"
latencyperiod = 0
#plot(network(M, directed = FALSE))
pt = proc.time()
epidemic = simseir(M = my_ergm, N = n_pop, beta = 0.3, ki = 1, thetai = 5, latencydist = "fixed", latencyperiod = 1)
proc.time() - pt
hist(as.data.frame(epidemic)$Etime)
hist(as.data.frame(epidemic)$Itime)
plotepitree(epidemic)
